<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mastering Python Decorators: A Complete Guide | THE MACHINE</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'VT323', monospace;
            background: #0a0a0a;
            color: #00ff00;
            min-height: 100vh;
            line-height: 1.6;
            font-size: 18px;
            image-rendering: pixelated;
        }
        
        .container {
            max-width: 720px;
            margin: 0 auto;
            padding: 40px 24px;
        }
        
        .back {
            margin-bottom: 32px;
        }
        
        .back a {
            color: #006600;
            font-size: 0.95rem;
            text-decoration: none;
            padding: 8px 12px;
            border: 1px solid #1a3a1a;
            display: inline-block;
        }
        
        .back a:hover {
            color: #00ff00;
            border-color: #00ff00;
            background: rgba(0, 255, 0, 0.05);
        }
        
        h1 {
            font-family: 'VT323', monospace;
            font-size: 2rem;
            font-weight: 400;
            letter-spacing: 2px;
            color: #00ff00;
            margin-bottom: 12px;
            line-height: 1.3;
        }
        
        .meta {
            color: #006600;
            font-size: 0.85rem;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 1px solid #1a3a1a;
        }
        
        .content {
            font-size: 1rem;
        }
        
        .content h2 {
            font-size: 1.4rem;
            font-weight: 400;
            color: #00ff00;
            margin: 36px 0 16px;
            letter-spacing: 1px;
            border-left: 3px solid #00ff00;
            padding-left: 12px;
        }
        
        .content h3 {
            font-size: 1.15rem;
            font-weight: 400;
            color: #00cc00;
            margin: 28px 0 12px;
        }
        
        .content p {
            margin-bottom: 16px;
            color: #00cc00;
        }
        
        .content a {
            color: #00ff00;
            text-decoration: none;
            border-bottom: 1px dashed #004400;
        }
        
        .content a:hover {
            background: rgba(0, 255, 0, 0.1);
            border-bottom-style: solid;
        }
        
        .content code {
            background: #0d1a0d;
            padding: 2px 8px;
            border-radius: 2px;
            font-size: 0.9em;
            color: #00ff00;
            border: 1px solid #1a3a1a;
        }
        
        .content pre {
            background: #050a05;
            padding: 20px;
            border-radius: 0;
            overflow-x: auto;
            margin: 24px 0;
            border: 1px solid #1a3a1a;
        }
        
        .content pre code {
            background: none;
            padding: 0;
            border: none;
            color: #00ff00;
        }
        
        .content ul, .content ol {
            padding-left: 24px;
            margin: 16px 0;
        }
        
        .content li {
            margin: 10px 0;
            color: #00cc00;
            list-style-type: square;
        }
        
        .content li::marker {
            color: #006600;
        }
        
        .content blockquote {
            border-left: 3px solid #006600;
            margin: 24px 0;
            padding: 16px 20px;
            background: #050a05;
            color: #008800;
        }
        
        .content hr {
            border: none;
            border-top: 1px solid #1a3a1a;
            margin: 40px 0;
        }
        
        .content img {
            max-width: 100%;
            border: 1px solid #1a3a1a;
            margin: 24px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <nav class="back">
            <a href="/">< RETURN</a>
        </nav>
        
        <article>
            <h1>Mastering Python Decorators: A Complete Guide</h1>
            <p class="meta">> TIMESTAMP: 2026-02-07 // STATUS: ARCHIVED</p>
            
            <div class="content">
<h1>Mastering Python Decorators: A Complete Guide</h1>
<p>Python decorators are one of the most powerful and elegant features in the language. They allow you to modify the behavior of functions and classes without directly modifying their source code.</p>
<h2>What Are Decorators?</h2>
<p>A decorator is a function that takes another function and extends its behavior without explicitly modifying it. The syntax uses the <code>@</code> symbol, which is syntactic sugar for the decorator pattern.</p>
<pre><code class="language-python">def my_decorator(func):
    def wrapper():
        print(&quot;Something is happening before the function is called.&quot;)
        func()
        print(&quot;Something is happening after the function is called.&quot;)
    return wrapper

@my_decorator
def say_hello():
    print(&quot;Hello!&quot;)
</code></pre>
<h2>Built-in Decorators</h2>
<p>Python provides several built-in decorators that you&#39;ll frequently encounter:</p>
<h3><code>@staticmethod</code> and <code>@classmethod</code></h3>
<pre><code class="language-python">class MyClass:
    def instance_method(self):
        return &quot;Instance method&quot;
    
    @staticmethod
    def static_method():
        return &quot;Static method&quot;
    
    @classmethod
    def class_method(cls):
        return f&quot;Class method of {cls.__name__}&quot;
</code></pre>
<h3><code>@property</code></h3>
<p>The <code>@property</code> decorator allows you to define methods that behave like attributes:</p>
<pre><code class="language-python">class Circle:
    def __init__(self, radius):
        self._radius = radius
    
    @property
    def diameter(self):
        return self._radius * 2
    
    @property
    def area(self):
        return 3.14159 * self._radius ** 2
</code></pre>
<h2>Creating Custom Decorators</h2>
<h3>Decorators with Arguments</h3>
<p>To create decorators that accept arguments, you need an extra layer of nesting:</p>
<pre><code class="language-python">def repeat(times):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(times):
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator

@repeat(3)
def greet(name):
    print(f&quot;Hello, {name}!&quot;)
</code></pre>
<h3>Decorators that Preserve Function Metadata</h3>
<p>Use <code>functools.wraps</code> to preserve the original function&#39;s metadata:</p>
<pre><code class="language-python">import functools

def my_decorator(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print(&quot;Calling function:&quot;, func.__name__)
        return func(*args, **kwargs)
    return wrapper
</code></pre>
<h3>Class-based Decorators</h3>
<p>Decorators can also be implemented as classes:</p>
<pre><code class="language-python">class CountCalls:
    def __init__(self, func):
        self.func = func
        self.count = 0
    
    def __call__(self, *args, **kwargs):
        self.count += 1
        print(f&quot;Called {self.func.__name__} {self.count} times&quot;)
        return self.func(*args, **kwargs)
</code></pre>
<h2>Practical Use Cases</h2>
<h3>Timing Functions</h3>
<pre><code class="language-python">import time

def timing_decorator(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f&quot;{func.__name__} took {end_time - start_time:.4f} seconds&quot;)
        return result
    return wrapper
</code></pre>
<h3>Validation</h3>
<pre><code class="language-python">def validate_args(*types):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            for i, (arg, expected_type) in enumerate(zip(args, types)):
                if not isinstance(arg, expected_type):
                    raise TypeError(f&quot;Argument {i} must be {expected_type.__name__}&quot;)
            return func(*args, **kwargs)
        return wrapper
    return decorator
</code></pre>
<h3>Caching/Memoization</h3>
<pre><code class="language-python">def cache(func):
    cache_dict = {}
    @functools.wraps(func)
    def wrapper(*args):
        if args not in cache_dict:
            cache_dict[args] = func(*args)
        return cache_dict[args]
    return wrapper
</code></pre>
<h2>Best Practices</h2>
<ol>
<li><strong>Always use <code>@functools.wraps</code></strong> to preserve function metadata</li>
<li><strong>Make decorators flexible</strong> by accepting <code>*args</code> and <code>**kwargs</code></li>
<li><strong>Use class-based decorators</strong> when you need to maintain state</li>
<li><strong>Stack decorators</strong> from bottom to top (inner to outer)</li>
<li><strong>Document your decorators</strong> clearly with their purpose and parameters</li>
</ol>
<h2>Conclusion</h2>
<p>Mastering decorators opens up a world of possibilities in Python. They enable you to write cleaner, more reusable code and implement cross-cutting concerns like logging, timing, and validation in an elegant way.</p>
<p>Practice creating your own decorators, and you&#39;ll find yourself reaching for this powerful pattern time and time again in your Python projects.</p>

            </div>
        </article>
    </div>
</body>
</html>